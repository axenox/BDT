<?php
namespace axenox\BDT\Behat\Contexts\UI5Facade;

use axenox\BDT\Behat\Contexts\UI5Facade\Nodes\UI5TileNode;
use Behat\Mink\Element\NodeElement;
use Behat\Mink\Session;
use exface\Core\Actions\Login;
use exface\Core\CommonLogic\Security\Authenticators\MetamodelAuthenticator;
use exface\Core\CommonLogic\Workbench;
use exface\Core\DataTypes\ComparatorDataType;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Facades\AbstractAjaxFacade\AbstractAjaxFacade;
use exface\Core\Factories\ActionFactory;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Factories\FacadeFactory;
use exface\Core\Factories\MetaObjectFactory;
use exface\Core\Factories\UiPageFactory;
use exface\Core\Factories\WidgetFactory;
use exface\Core\Interfaces\UserInterface;
use exface\Core\Interfaces\WorkbenchInterface;
use exface\UI5Facade\Facades\UI5Facade;
use PHPUnit\Framework\Assert;

/**
 * Allows to work with OpenUI5 apps generated by exface.UI5Facade
 * 
 *  This class provides methods for:
 * - Finding and interacting with UI5 controls
 * - Navigating within UI5 applications
 * - Handling UI5-specific wait conditions
 * - Monitoring AJAX/XHR requests
 * - Validating UI states and content
 * 
 * @author Andrej Kabachnik
 */
class UI5Browser
{
    private $session;
    private $workbench = null;
    private $facade = null;
    private $objectAlias = null;
    private UI5WaitManager $waitManager;
    private array $focusStack = [];

    /**
     * Constructor - initializes the UI5Browser with necessary dependencies
     * 
     * @param WorkbenchInterface $workbench The application workbench
     * @param mixed $session session for browser interaction
     * @param string $ui5AppUrl URL of the UI5 application to load
     */
    public function __construct(WorkbenchInterface $workbench, $session, string $ui5AppUrl)
    {
        $this->session = $session;
        $this->workbench = $workbench;
        $this->waitManager = new UI5WaitManager($session);

        // Initialize XHR monitoring to track AJAX requests
        $this->initializeXHRMonitoring();
        // Initial app load using waitManager to ensure it's fully loaded
        $this->waitManager->waitForAppLoaded($ui5AppUrl);
    }

    /**
     * Gets the wait manager instance that handles all wait operations
     * 
     * @return UI5WaitManager The wait manager instance
     */
    public function getWaitManager(): UI5WaitManager
    {
        return $this->waitManager;
    }

    /**
     * Returns the Mink session used for browser interaction
     * 
     * @return \Behat\Mink\Session Current browser session
     */
    protected function getSession(): Session
    {
        return $this->session;
    }


    /**
     * Returns the workbench instance for the application
     * 
     * @return Workbench Application workbench
     */
    public function getWorkbench()
    {
        return $this->workbench;
    }

    /**
     * Gets the UI5Facade instance used for UI5-specific operations
     * Lazy-loads the facade if not already instantiated
     * 
     * @return \exface\UI5Facade\Facades\UI5Facade UI5 facade instance
     */
    public function getFacade(): UI5Facade
    {
        if ($this->facade === null) {
            $this->facade = FacadeFactory::createFromString(UI5Facade::class, $this->getWorkbench());
        }
        return $this->facade;
    }

    /**
     * Sets the object alias used for filtering widget search results
     * This allows targeting specific widgets that contain the given alias text
     * For example, if searching for a table related to "Customer" data,
     * setting objectAlias to "Customer" will only return widgets containing that text
     *
     * @param string|null $alias The text to filter widgets by, null to clear filter
     * @return void
     */
    public function setObjectAlias(?string $alias): void
    {
        $this->objectAlias = $alias;
    }

    /**
     * Gets the current object alias used for widget filtering
     * Returns the text currently being used to filter widget search results,
     * or null if no filtering is active
     *
     * @return string|null The current object alias or null if not set
     */
    public function getObjectAlias(): ?string
    {
        return $this->objectAlias;
    }

    /**
     * Returns the current page object from the Mink session
     * 
     * @return \Behat\Mink\Element\DocumentElement Current page object
     */
    public function getPage()
    {
        return $this->session->getPage();
    }



    /**
     * Clears the XHR (XMLHttpRequest) monitoring log and resets error state
     * 
     * This function performs two main cleanup tasks:
     * 1. Clears the XHR log array in the browser (window.exfXHRLog)
     * 2. Resets the internal error tracking state
     * 
     * Use cases:
     * - Before starting a new test scenario
     * - After completing a test case
     * - When needing to reset monitoring state
     * - Before capturing new AJAX requests
     * 
     * Note: This should be called before any new AJAX monitoring to ensure
     * clean state and prevent mixing logs from different test scenarios
     * 
     * @return void
     * @see initializeXHRMonitoring() For the setup of the logging system
     */
    public function clearXHRLog(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            window.exfXHRLog = {
                requests: [],
                lastRequest: null,
                errors: []
            };
            JS
        );
    }

    /**
     * Clears all widget highlights added for debugging purposes
     * Removes visual indicators and tooltips from previously highlighted elements
     * 
     * @return void
     */
    public function clearWidgetHighlights(): void
    {
        try {
            $this->session->executeScript('
                if (window.clearHighlight) {
                    document.querySelectorAll("[style*=\'outline\']").forEach(el => {
                        if (el._debugLabel) {
                            window.clearHighlight(el);
                        }
                    });
                }
            ');
        } catch (\Exception $e) {
            return;
        }
    }



    /**
     * Handles wait operations before or after test steps
     * 
     * This method ensures the UI is in a stable state by waiting for:
     * - AJAX requests to complete
     * - UI5 busy indicators to disappear 
     * 
     * @param bool $isAfterStep True if called after a step, false if before
     * @return void
     * @throws \RuntimeException If wait operation fails
     */
    public function handleStepWaitOperations(bool $isAfterStep = true): void
    {
        try {
            if ($isAfterStep) {
                // After step: Wait for all operations to complete
                $this->waitManager->waitForPendingOperations(true, true, true);

            } else {
                // Before step: Limited wait for UI stabilization
                $this->waitManager->waitForPendingOperations(false, true, false);
            }
        } catch (\Exception $e) {
            throw new \RuntimeException(
                sprintf(
                    "Wait operation failed (%s step): %s",
                    $isAfterStep ? 'after' : 'before',
                    $e->getMessage()
                )
            );
        }
    }

    /**
     * Highlights a widget with visual indicator for debugging purposes
     * 
     * Adds a colored outline and label to the widget to make it visible
     * during test execution and debugging
     * 
     * @param NodeElement $node Widget element to highlight
     * @param string $widgetType Type of the widget (used in label)
     * @param int $index Index number of the widget
     * @return void
     */
    public function highlightWidget(NodeElement $node, string $widgetType, int $index): void
    {
        // Define colors for different widget types for visual distinction
        $colors = [
            'DataTable' => '#4CAF50',
            'Dialog' => '#2196F3',
            'Input' => '#FF9800',
            'default' => '#9C27B0'
        ];

        // Get color for widget type (fallback to default)
        $color = $colors[$widgetType] ?? $colors['default'];

        // Initialize highlighting function if not already done
        $this->initializeHighlighting();

        // Determine the widget's location context (dialog name, page, etc.)
        $location = "in page"; // Default location
        $parent = $node->find('xpath', './ancestor::*[contains(@class, "sapMPage") or contains(@class, "sapMPopup")][1]');
        if ($parent) {
            $title = $parent->find('css', '.sapMTitle');
            if ($title) {
                $location = "in " . trim($title->getText());
            }
        }

        // Apply the highlight to the element
        $this->session->executeScript(
            sprintf(
                'window.highlightElement(document.querySelector("#%s"), "%s", "%s #%d %s");',
                $node->getAttribute('id'),
                $color,
                $widgetType,
                $index + 1,
                $location
            )
        );
    }

    /**
     * Displays the name of the current test case on the UI.
     * 
     * This function creates a fixed position message div on the page 
     * that shows the name of the test case being executed. The div 
     * is styled to be visually distinct, with a selected colour background 
     * and white text, making it easy to identify during test execution.
     * 
     * The message div is created if it does not already exist, ensuring 
     * that it does not duplicate if the function is called multiple times.
     * 
     * @param string $testCaseName The name of the test case to display.
     * @return void
     */
    public function showTestCaseName(string $testCaseName): void
    {
        $this->session->executeScript(<<<JS
    (function() {
        // Check if the message div already exists
        let messageDiv = document.getElementById('testCaseNameDiv');
        
        // If it doesn't exist, create it
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'testCaseNameDiv'; // Set an ID for future reference
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '10px';
            messageDiv.style.right = '10px';
            messageDiv.style.backgroundColor = '#4CAF50'; // Green
            messageDiv.style.color = 'white';
            messageDiv.style.padding = '10px';
            messageDiv.style.borderRadius = '5px';
            messageDiv.style.zIndex = '9999';
            document.body.appendChild(messageDiv); 
        }
        
        // Update the text of the message div
        messageDiv.innerText = '' + '{$testCaseName}';
    })();
JS
        );
    }

    /**
     * Displays step timing information on the UI.
     * 
     * This function creates a fixed position message div on the page 
     * that shows the timing information for test steps. It displays:
     * - Step start time when a step begins
     * - Both start and end times plus duration when a step completes
     * 
     * The div is styled to be visually distinct from the test case name div,
     * positioned at the bottom right of the screen.
     * 
     * @param string $stepName The name of the step being executed
     * @param bool $isStepStart Whether this is the start or end of the step
     * @param float|null $startTime The start time of the step (timestamp)
     * @return float Current timestamp (can be used as startTime for end call)
     */
    public function showStepTiming(string $stepName, bool $isStepStart = true, ?float $startTime = null): float
    {
        $currentTime = microtime(true);
        $formattedTime = date('H:i:s', (int) $currentTime) . '.' . substr(number_format($currentTime - (int) $currentTime, 3), 2);

        if ($isStepStart) {
            // For step start, just show the start time
            $message = "Started at: {$formattedTime}";
        } else {
            // For step end, show start, end and duration
            $duration = $currentTime - $startTime;
            $formattedStartTime = date('H:i:s', (int) $startTime) . '.' . substr(number_format($startTime - (int) $startTime, 3), 2);
            $message = "Started: {$formattedStartTime}<br>Ended: {$formattedTime}<br>Duration: " . number_format($duration, 3) . " sec";
        }

        // Convert PHP boolean to JavaScript boolean string
        $isStepStartJS = $isStepStart ? 'false' : 'true';

        $this->session->executeScript(<<<JS
    (function() {
        // Check if the timing div already exists
        let timingDiv = document.getElementById('stepTimingDiv');
        
        // If it doesn't exist, create it
        if (!timingDiv) {
            timingDiv = document.createElement('div');
            timingDiv.id = 'stepTimingDiv';
            timingDiv.style.position = 'fixed';
            timingDiv.style.bottom = '10px';
            timingDiv.style.right = '10px';
            timingDiv.style.backgroundColor = '#2196F3'; // Blue color to distinguish from test case name
            timingDiv.style.color = 'white';
            timingDiv.style.padding = '10px';
            timingDiv.style.borderRadius = '5px';
            timingDiv.style.zIndex = '9999';
            timingDiv.style.fontFamily = 'monospace'; // For better readability of times
            timingDiv.style.fontSize = '14px';
            timingDiv.style.maxWidth = '300px';
            document.body.appendChild(timingDiv);
        }
        
        // Updading the text of the timing div
        timingDiv.innerHTML = '<strong>Step: {$stepName}</strong><br>' + '{$message}';
        
        // If this is the end of the step, wait 1 second and then update the div
        if ({$isStepStartJS}) {
            setTimeout(function() {
                timingDiv.innerHTML += '<br><em>Continuing in 1s...</em>';
            }, 0);
            
            // Wait 1 second before next step
            setTimeout(function() {
                // You can clear or update the message here if needed
            }, 1000);
        }
    })();
JS
        );

        // Return current time so it can be used as startTime for the end call
        return $currentTime;
    }


    /**
     * Initializes the highlighting functionality in browser
     * Creates JavaScript functions for adding and removing highlights
     * 
     * @return void
     */
    private function initializeHighlighting(): void
    {
        $this->session->executeScript(<<<'JS'
    if (typeof window.highlightElement === 'undefined') {
        window.highlightElement = function(element, color, label) {
            const rect = element.getBoundingClientRect();
            
            // Create label with location context
            const debugLabel = document.createElement('div');
            debugLabel.style.cssText = 'position: absolute;' +
                'background: ' + color + ';' +
                'color: white;' +
                'padding: 4px 8px;' +
                'border-radius: 4px;' +
                'font-size: 12px;' +
                'z-index: 9999;' +
                'pointer-events: none;';
            debugLabel.textContent = label;
            
            // Position above element
            debugLabel.style.top = (rect.top + window.scrollY - 25) + 'px';
            debugLabel.style.left = rect.left + 'px';
            
            // Add highlight to element
            element.style.outline = '2px solid ' + color;
            element.style.backgroundColor = color + '33';
            
            // Store info for cleanup
            element._debugLabel = debugLabel;
            element._originalStyles = {
                outline: element.style.outline,
                background: element.style.backgroundColor
            };
            
            document.body.appendChild(debugLabel);
        };

        window.clearHighlight = function(element) {
            if (element._debugLabel) {
                element._debugLabel.remove();
                element.style.outline = element._originalStyles.outline;
                element.style.backgroundColor = element._originalStyles.background;
                delete element._debugLabel;
                delete element._originalStyles;
            }
        };
    }
    JS);
    }

    /**
     * Helper function to get widget location description
     * Used to provide context about where in the UI a widget is located
     * 
     * @param NodeElement $widget The widget to get location for
     * @return string Human-readable location description
     */
    public function getWidgetLocation(NodeElement $widget): string
    {
        $parent = $widget->find('xpath', './ancestor::*[contains(@class, "sapMPage") or contains(@class, "sapMPopup")][1]');
        if ($parent) {
            $title = $parent->find('css', '.sapMTitle');
            if ($title) {
                return "in " . trim($title->getText());
            }
        }
        return "in page";
    }


    /**
     * Handles input into a ComboBox control
     * Clicks the dropdown arrow and selects the option with matching text
     * 
     * @param NodeElement $comboBox The ComboBox control
     * @param string $value The value to select from dropdown
     * @return void
     * @throws \RuntimeException If ComboBox arrow or option can't be found
     */
    public function handleComboBoxInput(NodeElement $comboBox, string $value): void
    {
        // Find the dropdown arrow button
        $arrow = $comboBox->find('css', '.sapMInputBaseIconContainer');
        if (!$arrow) {
            throw new \RuntimeException("Could not find ComboBox dropdown arrow");
        }

        // Click to open the dropdown
        $arrow->click();

        // Find the option with matching text
        $item = $this->getPage()->find(
            'css',
            ".sapMSelectList li:contains('{$value}'), " .
            ".sapMComboBoxItem:contains('{$value}'), " .
            ".sapMMultiComboBoxItem:contains('{$value}')"
        );

        if (!$item) {
            throw new \RuntimeException("Could not find option '{$value}' in ComboBox list");
        }

        $item->click();
    }

    /**
     * Handles input into a Select control
     * Selects the option with matching text from dropdown
     * 
     * @param NodeElement $select The Select control
     * @param string $value The value to select
     * @return void
     * @throws \RuntimeException If option can't be found
     */
    public function handleSelectInput(NodeElement $select, string $value): void
    {
        // Find the option with matching text
        $item = $this->getPage()->find('css', ".sapMSelectList li:contains('{$value}')");

        if (!$item) {
            throw new \RuntimeException("Could not find option '{$value}' in Select list");
        }

        $item->click();
    }

    /**
     * Sets focus on a node and maintains a focus stack
     * Used to track which elements have focus during test execution
     * 
     * @param NodeElement $node The element to focus
     * @return void
     */
    public function focus(NodeElement $node): void
    {
        $top = end($this->focusStack);
        if ($top !== $node) {
            $this->focusStack[] = $node;
        }
    }

    /**
     * Gets the currently focused node
     * Returns the top element of the focus stack
     * 
     * @return NodeElement|null The focused element or null if none focused
     */
    public function getFocusedNode(): ?NodeElement
    {
        if (empty($this->focusStack)) {
            return null;
        }
        $top = end($this->focusStack);
        return $top;
    }

    /**
     * Retrieves the type of the currently focused UI5 widget
     * 
     * @return string|null The type of the focused widget (e.g., 'DataTable', 'Dialog')
     * @description Returns the widget type if a widget is currently in focus, otherwise null
     */
    public function getFocusedType(): ?string
    {
        if (empty($this->focusStack)) {
            return null;
        }

        $current = end($this->focusStack);
        return $current['type'];
    }

    /**
     * Removes the current focus from the widget stack
     * 
     * @description Pops the top element from the focus stack, effectively unfocusing the current widget
     */
    public function unfocus(): void
    {
        if (!empty($this->focusStack)) {
            array_pop($this->focusStack);
        }
    }

    /**
     * Completely clears the entire focus stack
     * 
     * @description Resets the focus stack to an empty state, removing all previously focused widgets
     */
    public function clearFocus(): void
    {
        $this->focusStack = [];
    }

    /**
     * Gets current URL with hash fragment
     * This ensures we get the complete URL including UI5 routing information
     * 
     * @return string Complete URL including hash
     */
    public function getCurrentUrlWithHash(): string
    {
        return $this->session->evaluateScript('
        (function() {
            var baseUrl = window.location.href;
            var hash = window.location.hash;
            
            // Check for UI5 specific hash handling
            if (typeof sap !== "undefined" && 
                sap.ui && 
                sap.ui.core && 
                sap.ui.core.routing && 
                sap.ui.core.routing.HashChanger) {
                
                try {
                    // Get hash from UI5 router
                    hash = "#" + sap.ui.core.routing.HashChanger.getInstance().getHash();
                } catch(e) {
                    // Fallback to browser hash if UI5 router not available
                    console.warn("UI5 router not available:", e);
                }
            }
            
            // Ensure we don\'t duplicate the hash
            baseUrl = baseUrl.split("#")[0];
            
            return baseUrl + (hash || "");
        })();
    ');
    }


    /**
     * Verifies table content against expected values
     * Checks if specified column contains expected text
     * 
     * @param NodeElement $table The table to verify
     * @param array $expectedContent Array of expected content (column => text pairs)
     * @return void
     * @throws \RuntimeException If verification fails
     */
    public function verifyTableContent(NodeElement $table, array $expectedContent): void
    {
        try {
            // Check each expected content item
            foreach ($expectedContent as $content) {
                $columnName = $content['column'];
                $searchText = trim($content['text'], '"\'');
                $found = false;

                // First find column headers
                $headers = $table->findAll('css', '.sapUiTableHeaderDataCell label, .sapMListTblHeader .sapMColumnHeader');
                $columnIndex = null;

                // Find the column index
                foreach ($headers as $index => $header) {
                    $headerText = trim($header->getText());
                    if ($headerText === $columnName) {
                        $columnIndex = $index;
                        break;
                    }
                }

                Assert::assertNotNull($columnIndex, "Column '$columnName' not found in table");

                // Check table cells
                $rows = $table->findAll('css', '.sapUiTableContentRow, .sapMListTblRow');
                foreach ($rows as $row) {
                    $cells = $row->findAll('css', '.sapUiTableCell, .sapMListTblCell');
                    if (isset($cells[$columnIndex])) {
                        $cell = $cells[$columnIndex];

                        // Check different UI5 text elements
                        $textElements = $cell->findAll(
                            'css',
                            '.sapMText, .sapMLabel, .sapMObjectNumber, ' .
                            '.sapMPI .sapMPITextLeft, .sapMPI .sapMPITextRight, ' .
                            '.sapMObjStatus .sapMObjStatusText'
                        );

                        foreach ($textElements as $element) {
                            if (stripos($element->getText(), $searchText) !== false) {
                                $found = true;
                                break 2;
                            }
                        }
                    }
                }

                Assert::assertTrue($found, "Text '$searchText' not found in column '$columnName'");
            }

        } catch (\Exception $e) {
            throw new \RuntimeException(
                // sprintf(
                //     "Failed to verify table content. Error: %s\nTable structure: %s",
                //     $e->getMessage(),
                //     $table->getOuterHtml()
                // )
                sprintf(
                    "Failed to verify table content"
                )
            );
        }
    }




    /**
     * Initializes XHR and AJAX Request Monitoring System
     * 
     * This function sets up a comprehensive monitoring system for all network requests by:
     * - Creating a wrapper around XMLHttpRequest without modifying its core functionality (Uses wrapper pattern instead of modifying original XHR)
     * - Monitoring jQuery AJAX calls through $.ajaxSetup
     * - Tracking all fetch API requests , Catches HTTP errors (400, 500 etc.)
     * 
     * Features:
     * - Captures all network activity including status codes and responses
     * - Detects HTTP errors (400, 500 etc.) and UI5 specific errors
     * - Logs detailed request information (timestamps, duration, responses)
     * - Stores logs separately in window.exfXHRLog without affecting application
     * 
     * Use Cases:
     * - Test automation error detection
     * - Network request debugging
     * - Error state capturing
     * - Automatic error logging
     * 
     * @method initializeXHRMonitoring
     * @return void
     * @throws \RuntimeException if XHR monitoring initialization fails
     */
    public function initializeXHRMonitoring(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            (function() {
                // Global error manager
                window.exfErrorManager = {
                    processedErrors: new Set(),
                    addError: function(error) {
                        const hash = this.generateErrorHash(error);
                        if (!this.processedErrors.has(hash)) {
                            this.processedErrors.add(hash);
                            console.error('Error logged:', error);
                        }
                    },
                    generateErrorHash: function(error) {
                        const url = (error.url || '').replace(/[?&][^=]*=[^&]*/g, '');
                        return `\${error.type}|\${error.status}|\${url}`;
                    }
                };
    
                // XHR logging object with improved error handling
                window.exfXHRLog = {
                    requests: [],
                    errors: [],
                    addRequest: function(request) {
                        request.timestamp = new Date().toISOString();
                        this.requests.push(request);
                        
                        if (request.status >= 400) {
                            const error = {
                                type: 'Network',
                                status: request.status,
                                url: request.url,
                                message: request.statusText,
                                response: request.response,
                                timestamp: request.timestamp
                            };
                            
                            window.exfErrorManager.addError(error);
                            this.errors.push(error);
                        }
                    }
                };
    
                // Enhance jQuery AJAX monitoring
                if (typeof jQuery !== 'undefined') {
                    const originalAjax = jQuery.ajax;
                    jQuery.ajax = function(options) {
                        const startTime = Date.now();
                        const originalComplete = options.complete;
                        
                        options.complete = function(jqXHR, textStatus) {
                            try {
                                const request = {
                                    url: options.url,
                                    method: options.type || 'GET',
                                    status: jqXHR.status,
                                    statusText: jqXHR.statusText,
                                    response: jqXHR.responseText,
                                    duration: Date.now() - startTime
                                };
                                
                                window.exfXHRLog.addRequest(request);
                                
                                if (originalComplete) {
                                    originalComplete.apply(this, arguments);
                                }
                            } catch (e) {
                                window.exfErrorManager.addError({
                                    type: 'JSError',
                                    message: e.message,
                                    stack: e.stack
                                });
                            }
                        };
                        
                        return originalAjax.apply(this, arguments);
                    };
                }
    
                // Enhanced fetch API monitoring
                if (typeof window.fetch === 'function') {
                    const originalFetch = window.fetch;
                    window.fetch = async function(input, init) {
                        const startTime = Date.now();
                        const url = typeof input === 'string' ? input : input.url;
                        const method = init?.method || 'GET';
                        
                        try {
                            const response = await originalFetch.apply(this, arguments);
                            const clone = response.clone();
                            const responseText = await clone.text();
                            
                            window.exfXHRLog.addRequest({
                                url: url,
                                method: method,
                                status: response.status,
                                statusText: response.statusText,
                                response: responseText,
                                duration: Date.now() - startTime
                            });
                            
                            return response;
                        } catch (error) {
                            const errorDetails = {
                                url: url,
                                method: method,
                                status: 0,
                                statusText: error.message,
                                error: error.toString(),
                                duration: Date.now() - startTime
                            };
                            
                            window.exfXHRLog.addRequest(errorDetails);
                            window.exfErrorManager.addError({
                                type: 'FetchError',
                                message: error.message,
                                url: url
                            });
                            
                            throw error;
                        }
                    };
                }
    
                console.log('Enhanced XHR monitoring initialized successfully');
            })();
            JS
        );

        // Verify initialization
        $isInitialized = $this->getSession()->evaluateScript(
            'return typeof window.exfXHRLog !== "undefined" && typeof window.exfXHRLog.addRequest === "function"'
        );

        if (!$isInitialized) {
            throw new \RuntimeException('XHR monitoring initialization failed');
        }
    }




    /**
     * Finds an input element by its associated label caption in a UI5 application
     * 
     * This function performs a hierarchical search to find input elements:
     * 1. First finds the label element with matching caption
     * 2. Then locates the corresponding input through the label's 'for' attribute
     * 3. Handles different UI5 input structures and nested elements
     * 
     * @param string $caption The label text to search for
     * @param \Behat\Mink\Element\NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found input element or null if not found
     */
    public function findInputByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        // Get the page or use provided parent element as search context
        $page = $this->getPage();
        $input = null;

        // Find all label BDI elements (UI5 uses BDI for bidirectional text support)
        $labelBdis = ($parent ?? $page)->findAll('css', 'label.sapMLabel > span > bdi');

        // Iterate through found labels to locate matching one
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                try {
                    // Navigate from BDI to actual label element
                    $sapMLabel = $labelBdi->getParent()->getParent();
                    $labelFor = $sapMLabel->getAttribute('for');

                    // First attempt: Try to find input directly by ID
                    $input = ($parent ?? $page)->findById($labelFor);

                    // Second attempt: Look for inner input element
                    // UI5 often wraps inputs in containers with -inner suffix
                    if (!$input) {
                        $input = ($parent ?? $page)->find('css', '#' . $labelFor . '-inner');
                    }

                    // Third attempt: Check for nested input within container
                    // Some UI5 controls have complex DOM structures
                    if (!$input) {
                        $inputContainer = ($parent ?? $page)->find('css', '#' . $labelFor);
                        if ($inputContainer) {
                            $input = $inputContainer->find('css', 'input.sapMInputBaseInner');
                        }
                    }
                    // If input found, break the loop
                    if ($input) {
                        break;
                    }
                } catch (\Exception $e) {
                    continue;
                }
            }
        }

        return $input;
    }

    /**
     * Finds a tab element by its caption text
     * 
     * @param string $caption The tab caption to search for
     * @param NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found tab element or null if not found
     */
    public function findTabByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $selectors = ['.sapMITBItem .sapMITHTextContent ', '.sapUxAPAnchorBarScrollContainer > div > button.sapMBtn > span > span > bdi'];
        // Find all tab heading elements
        $tabHeadings = ($parent ?? $this->getPage())->findAll('css', implode(',', $selectors));

        // Iterate through found tab headings to locate matching one
        foreach ($tabHeadings as $tabHeading) {
            if ($tabHeading->getText() === $caption && $tabHeading->isVisible()) {
                // Return the parent tab element (navigate up to the actual tab container)
                return $tabHeading->getParent()->getParent()->getParent();
            }
        }
        return null;
    }

    /**
     * Finds a column by its caption text
     * 
     * @param string $caption The column caption to search for
     * @param NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found column element or null if not found
     */
    public function findColumnByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        
        $columnHeadings = ($parent ?? $this->getPage())->findAll('css', '.sapUiTableHeaderCell');

        // Iterate through found column headings to locate matching one
        foreach ($columnHeadings as $columnHeading) {
            if ($columnHeading->getText() === $caption && $columnHeading->isVisible()) {
                // Return the column element
                return $columnHeading;
            }
        }
        return null;
    }

    /**
     * Navigates to a specific tab by caption
     * If the tab is not already active, clicks it to activate
     * 
     * @param string $caption Tab caption to find and navigate to
     * @param NodeElement|null $parent Optional parent element to search within
     * @param int $attempts Number of attempts to find the tab
     * @return NodeElement|null The found tab element or null if not found
     * @throws \PHPUnit\Framework\AssertionFailedError If tab cannot be found
     */
    public function goToTab(string $caption, NodeElement $parent = null, int $attempts = 1): ?NodeElement
    {
        $tab = $this->findTabByCaption($caption, $parent);
        if ($tab === null && $attempts > 1) {
            // Try again after waiting for UI updates
            $attempts--;
            return $this->goToTab($caption, $parent, $attempts);
        }
        Assert::assertNotNull($tab, 'Cannot find tab "' . $caption . '"');
        // If the tab is not active, click on it to switch to the right authenticator
        if (!$tab->hasClass('sapMITBSelected')) {
            $tab->click();
        }
        return $tab;
    }

    /**
     * Finds a button element by its caption text
     * 
     * @param string $caption The button text to search for
     * @param NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found button element or null if not found
     */
    public function findButtonByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $page = $this->getPage();
        $button = null;
        // Find all button elements with BDI text container
        $labelBdis = ($parent ?? $page)->findAll('css', 'button.sapMBtn > span > span > bdi');
        // Check each button's text content
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                // Navigate up to the actual button element
                $button = $labelBdi->getParent()->getParent()->getParent();
                break;
            }
        }
        return $button;
    }






    /**
     * Finds and returns visible widgets based on specific criteria
     * 
     * This method performs a comprehensive search for UI5 widgets with the following features:
     * - Searches for widgets using a generalized CSS selector
     * - Waits for pending operations to complete before searching
     * - Filters widgets by type and optional object alias
     * - Ensures only visible widgets are returned
     * 
     * @param string $widgetType The type of widget to search for (e.g., 'DataTable')
     * @param string|null $objectAlias Optional text to filter widgets by their title or content
     * @param int $timeoutInSeconds Maximum time to wait for widgets to be available (default: 10 seconds)
     * 
     * @return NodeElement[] Array of visible widget nodes matching the search criteria
     * 
     * Search Strategy:
     * - Uses CSS class-based widget identification
     * - Performs visibility and alias-based filtering
     * - Supports case-insensitive partial matching for object alias
     */
    public function findWidgets(string $widgetType, ?string $objectAlias = null, int $timeoutInSeconds = 10): array
    {
        // Generate a generalized CSS selector for the specific widget type
        $cssSelector = ".exfw-{$widgetType}";

        // Wait for all pending operations to complete
        $this->waitManager->waitForPendingOperations(true, true, true,15);
        if ($timeoutInSeconds > 0) {
            $this->waitManager->waitForDOMElements($cssSelector, $timeoutInSeconds);
        }
        // Find all widgets on the page matching the CSS selector
        $page = $this->getPage();
        $widgets = $page->findAll('css', $cssSelector);

        // Filter widgets based on visibility and optional object alias
        $visibleWidgets = array_filter($widgets, function ($widget) use ($objectAlias) {

            // Return only visible widgets
            return $widget->isVisible();
        });

        return $visibleWidgets;
    }

    /**
     * Summary of findTiles
     * 
     * @return \axenox\BDT\Behat\Contexts\UI5Facade\Nodes\UI5TileNode[]
     */
    public function findTiles(): array
    {
        // Find tiles on the page
        $nodes = $this->findWidgets("Tile");

        // Store the tile names on the page
        $tiles = [];
        foreach ($nodes ?? [] as $node) {
            $tile = new UI5TileNode($node);
            $tiles[] = $tile;
        }
        Assert::assertNotEmpty($tiles, 'No tiles found');
        return $tiles;
    }

    /**
     * Find a button within exfw-datatable with exact text match
     * 
     * This method searches for buttons inside exfw-datatable divs
     * with a specific text in the <bdi> element
     * 
     * @param string $buttonText The exact text to search for in the button
     * @param string|null $tableName Optional table/section name to narrow down search
     * @return NodeElement|null The found button or null if not found
     */
    public function findButton(string $buttonText, string $tableName = null): ?NodeElement
    {
        // Construct base XPath to find buttons in exfw-datatable with exact <bdi> text
        $xpath = sprintf(
            "//div[contains(@class, 'exfw-datatable')]" .  // Find within datatable divs
            "//button[.//bdi[text()='%s']]",  // Button with <bdi> containing exact text
            $buttonText
        );

        // If a specific table/section name is provided, refine the search
        if ($tableName) {
            $xpath = sprintf(
                "//div[contains(@class, 'exfw-datatable') and contains(@id, '%s')]" . // Specific datatable
                "//button[.//bdi[text()='%s']]",  // Button with exact text
                $tableName,
                $buttonText
            );
        }

        // Perform the XPath search and return the result
        $button = $this->getSession()->find('xpath', $xpath);

        return $button;
    }


    /**
     * Converts ordinal numbers like "1." to zero-based indices
     * 
     * @param string $ordinal The ordinal number (e.g., "1.", "2.")
     * @return int Zero-based index
     */
    public function convertOrdinalToIndex($ordinal)
    {
        // Remove any trailing period and convert to integer
        $number = (int) str_replace('.', '', $ordinal);
        // Convert to zero-based index
        return $number - 1;
    }

    /**
     * Validates if a DOM element represents a proper UI5 table structure
     * @param NodeElement $element Element to check
     * @return bool True if element is a valid dialog
     */
    protected function isValidDialog(NodeElement $element): bool
    {
        try {
            // Must be visible
            // First check: Element must be visible in the DOM
            // This ensures we're not processing hidden template elements
            if (!$element->isVisible()) {
                return false;
            }

            // Check for essential dialog attributes
            $role = $element->getAttribute('role');
            $classes = $element->getAttribute('class');

            // Must have dialog role or specific dialog classes
            if (
                $role !== 'dialog' &&
                !preg_match('/(sapMDialog|sapMMessageDialog|sapMPopover)/', $classes)
            ) {
                return false;
            }

            // Should have either a header or content section
            $hasHeader = $element->find('css', '.sapMDialogTitle, .sapMIBar-CTX') !== null;
            $hasContent = $element->find('css', '.sapMDialogSection, .sapMDialogContent') !== null;

            return $hasHeader || $hasContent;

        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Extracts text content from a dialog element
     * 
     * @param NodeElement $element Dialog element
     * @return string Concatenated text content
     */
    protected function extractDialogText(NodeElement $element): string
    {
        $textParts = [];

        try {
            // Get header title 
            $headerTitle = $element->find('css', '.sapMDialogTitle, .sapMIBar-CTX .sapMTitle');
            if ($headerTitle) {
                $textParts[] = trim($headerTitle->getText());
            }

            // Get content text
            $textElements = $element->findAll('css', '.sapMDialogContent .sapMText, .sapMDialogContent .sapMLabel');
            foreach ($textElements as $textElement) {
                $text = trim($textElement->getText());
                if (!empty($text)) {
                    $textParts[] = $text;
                }
            }

            // Get button texts
            $buttons = $element->findAll('css', '.sapMDialogFooter .sapMBtn, .sapMBar-CTX .sapMBtn');
            foreach ($buttons as $button) {
                $buttonText = $button->find('css', '.sapMBtnContent');
                if ($buttonText) {
                    $textParts[] = trim($buttonText->getText());
                }
            }

        } catch (\Exception $e) {
            // If any error occurs, return empty string
            return '';
        }

        return implode(' ', array_filter($textParts));
    }

    /**
     * Validates if a DOM element represents a proper UI5 table structure
     *  
     * 
     * @param NodeElement $table The element to validate as a table
     * @return bool True if element is a valid UI5 table, false otherwise
     */
    protected function isValidTable(NodeElement $table): bool
    {
        try {
            // First check: Element must be visible in the DOM
            // This ensures we're not processing hidden template elements
            if (!$table->isVisible()) {
                return false;
            }

            // Second check: Look for table structural elements
            // Search for both standard table headers (th) and UI5 grid headers (role="columnheader")
            $hasHeaders = count($table->findAll('css', 'th, [role="columnheader"]')) > 0;
            // Third check: Look for table cells
            // Search for both standard cells (td) and UI5 grid cells (role="gridcell")
            $hasCells = count($table->findAll('css', 'td, [role="gridcell"]')) > 0;

            // A valid table must have either headers or cells
            // - Headers without cells: Empty table with column definitions
            // - Cells without headers: Data grid without column labels
            // - Both headers and cells: Standard populated table
            return $hasHeaders || $hasCells;

        } catch (\Exception $e) {
            // If any error occurs during validation (e.g., stale element reference)
            // consider the table invalid
            return false;
        }
    }

    /**
     * Returns the type of the widget, that the given node belongs to
     * 
     * @param \Behat\Mink\Element\NodeElement $node
     * @return bool|string|null
     */
    public function getNodeWidgetType(NodeElement $node): ?string
    {
        $classes = $node->getAttribute('class');
        $type = null;
        foreach (explode(' ', $classes ?? '') as $class) {
            if (mb_stripos($class, 'exfw-') === 0) {
                $type = StringDataType::substringAfter($class, 'exfw-');
            }
        }
        if ($type === null) {
            // TODO search the parents of the node for the first one with `exfw` CSS class
            // and take the widget type from that node
        }
        return $type;
    }



    /**
     * 
     * @param string $pageUrl
     * @param string $widgetId
     * @param string $assertWidgetType
     * @return \exface\Core\Interfaces\WidgetInterface
     */
    protected function getWidget(string $pageUrl, string $widgetId = null, string $assertWidgetType = null)
    {
        $page = UiPageFactory::createFromModel($this->getWorkbench(), $pageUrl);
        $widget = $widgetId !== null ? $page->getWidget($widgetId) : $page->getWidgetRoot();
        if ($assertWidgetType !== null) {
            Assert::assertEquals($assertWidgetType, $widget->getType(), 'Widget ' . $widgetId . ' is not of expected type "' . $assertWidgetType . '"!');
        }
        return $widget;
    }


    public static function setupUser(WorkbenchInterface $workbench, array $roles, string $locale = null): array
    {
        $config = $workbench->getApp('axenox.BDT')->getConfig();
        $userSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER');
        $userSheet->getFilters()->addConditionFromString('USERNAME', $config->getOption('TEST_USER.USERNAME'), ComparatorDataType::EQUALS);
        $userSheet->getColumns()->addFromSystemAttributes();
        $userSheet->getColumns()->addMultiple([
            'USERNAME'
        ]);
        $userSheet->dataRead();
        if ($userSheet->isEmpty()) {
            $userSheet->addRow([
                'USERNAME' => $config->getOption('TEST_USER.USERNAME'),
                'PASSWORD' => $config->getOption('TEST_USER.PASSWORD'),
                'FIRST_NAME' => $config->getOption('TEST_USER.FIRST_NAME'),
                'LAST_NAME' => $config->getOption('TEST_USER.LAST_NAME'),
                'LOCALE' => $workbench->getConfig()->getOption('SERVER.DEFAULT_LOCALE')
            ]);
            $userSheet->dataCreate();
        }
        $userId = $userSheet->getUidColumn()->getValue(0);

        if ($locale) {
            $userSheet->setCellValue('LOCALE', 0, $locale);
        }

        if (!empty($roles)) {
            $roleSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE');
            $roleSheet->getColumns()->addFromSystemAttributes();
            $roleSheet->getFilters()
                ->addNestedOR()
                ->addConditionFromValueArray('ALIAS_WITH_NS', $roles)
                ->addConditionFromValueArray('NAME', $roles);
            $roleSheet->dataRead();

            $userRoleSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE_USERS');
            $userRoleSheet->getFilters()->addConditionFromString('USER', $userId);
            foreach ($roleSheet->getUidColumn()->getValues() as $roleUid) {
                $userRoleSheet->addRow([
                    'USER_ROLE' => $roleUid
                ]);
            }
            $userSheet->setCellValue('USER_ROLE_USERS', 0, $userRoleSheet->exportUxonObject()->toArray());
        }
        $userSheet->dataUpdate();

        $loginFields = [];
        foreach ($workbench->getConfig()->getOption('SECURITY.AUTHENTICATORS') as $authUxon) {
            if ($authUxon->getProperty('class') === '\\' . MetamodelAuthenticator::class) {
                $loginDataObj = MetaObjectFactory::createFromString($workbench, 'exface.Core.LOGIN_DATA');
                $loginFields['_tab'] = $authUxon->getProperty('name') ?? $workbench->getCoreApp()->getTranslator()->translate('SECURITY.SIGN_IN');
                $loginFields[$loginDataObj->getAttribute('USERNAME')->getName()] = $config->getOption('TEST_USER.USERNAME');
                $loginFields[$loginDataObj->getAttribute('PASSWORD')->getName()] = $config->getOption('TEST_USER.PASSWORD');
                $loginAction = ActionFactory::createFromString($workbench, Login::class);
                $loginFields['_button'] = $loginAction->getName();
            }
        }
        return $loginFields;
    }

    public static function resetUser(WorkbenchInterface $workbench): void
    {
        $config = $workbench->getApp('axenox.BDT')->getConfig();
        $dataSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE_USERS');
        $dataSheet->getFilters()->addConditionFromString('USER__USERNAME', $config->getOption('TEST_USER.USERNAME'), ComparatorDataType::EQUALS);
        $dataSheet->dataDelete();
        return;
    }

    private function getCurrentUrlInfo(): array
    {

        return $this->getSession()->evaluateScript('
        (function() {
            var baseUrl = window.location.href.split("#")[0];
            var fullUrl = window.location.href;
            
            // UI5 specific routing information
            var ui5Hash = "";
            if (typeof sap !== "undefined" && 
                sap.ui && 
                sap.ui.core && 
                sap.ui.core.routing && 
                sap.ui.core.routing.HashChanger) {
                
                try {
                    // Get the current hash from UI5 router
                    ui5Hash = sap.ui.core.routing.HashChanger.getInstance().getHash();
                } catch(e) {
                    ui5Hash = window.location.hash.replace("#", "");
                }
            } else {
                ui5Hash = window.location.hash.replace("#", "");
            }
            
            return {
                baseUrl: baseUrl,
                fullUrl: fullUrl,
                hash: ui5Hash
            };
        })()
    ');
    }

}