<?php
namespace axenox\BDT\Behat\Contexts\UI5Facade;

use Behat\Mink\Element\NodeElement;
use Behat\Mink\Session;
use exface\Core\Actions\Login;
use exface\Core\CommonLogic\Security\Authenticators\MetamodelAuthenticator;
use exface\Core\CommonLogic\Workbench;
use exface\Core\DataTypes\ComparatorDataType;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Facades\AbstractAjaxFacade\AbstractAjaxFacade;
use exface\Core\Factories\ActionFactory;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Factories\FacadeFactory;
use exface\Core\Factories\MetaObjectFactory;
use exface\Core\Factories\UiPageFactory;
use exface\Core\Factories\WidgetFactory;
use exface\Core\Interfaces\UserInterface;
use exface\Core\Interfaces\WorkbenchInterface;
use exface\UI5Facade\Facades\UI5Facade;
use PHPUnit\Framework\Assert;

/**
 * Allows to work with OpenUI5 apps generated by exface.UI5Facade
 * 
 * @author Andrej Kabachnik
 */
class UI5Browser
{ 
    private $session;
    private $workbench = null;
    private $facade = null;
    private $objectAlias = null;
    private UI5WaitManager $waitManager;


    public function __construct(WorkbenchInterface $workbench, $session, string $ui5AppUrl)
    {
        $this->session = $session;
        $this->workbench = $workbench;
        $this->waitManager = new UI5WaitManager($session);

        // Initialize XHR monitoring
        $this->initializeXHRMonitoring();
        // Initial app load using waitManager
        $this->waitManager->waitForAppLoaded($ui5AppUrl);
    }

    /**
     * Gets the wait manager instance
     */
    public function getWaitManager(): UI5WaitManager
    {
        return $this->waitManager;
    }

    /**
     * 
     * @return \Behat\Mink\Session
     */
    protected function getSession(): Session
    {
        return $this->session;
    }


    /**
     * 
     * @return Workbench
     */
    public function getWorkbench()
    {
        return $this->workbench;
    }

    /**
     * 
     * @return \exface\UI5Facade\Facades\UI5Facade
     */
    public function getFacade(): UI5Facade
    {
        if ($this->facade === null) {
            $this->facade = FacadeFactory::createFromString(UI5Facade::class, $this->getWorkbench());
        }
        return $this->facade;
    }
 
    /**
     * Sets the object alias used for filtering widget search results
     * This allows targeting specific widgets that contain the given alias text
     * For example, if searching for a table related to "Customer" data,
     * setting objectAlias to "Customer" will only return widgets containing that text
     *
     * @param string|null $alias The text to filter widgets by, null to clear filter
     * @return void
     */
    public function setObjectAlias(?string $alias): void
    {
        $this->objectAlias = $alias;
    }

    /**
     * Gets the current object alias used for widget filtering
     * Returns the text currently being used to filter widget search results,
     * or null if no filtering is active
     *
     * @return string|null The current object alias or null if not set
     */
    public function getObjectAlias(): ?string
    {
        return $this->objectAlias;
    }
    // //// SAMPLE
    //     // Let's say we have multiple tables on the page:
    // // - Customer Table
    // // - Order Table
    // // - Product Table

    // // To find only the Customer table:
    // $browser->setObjectAlias("Customer");
    // $widgets = $browser->findWidgets("DataTable");
    // // This will only find tables containing the word "Customer"

    public function getPage()
    {
        return $this->session->getPage();
    }

 
    
   /**
     * Clears the XHR (XMLHttpRequest) monitoring log and resets error state
     * 
     * This function performs two main cleanup tasks:
     * 1. Clears the XHR log array in the browser (window.exfXHRLog)
     * 2. Resets the internal error tracking state
     * 
     * Use cases:
     * - Before starting a new test scenario
     * - After completing a test case
     * - When needing to reset monitoring state
     * - Before capturing new AJAX requests
     * 
     * Note: This should be called before any new AJAX monitoring to ensure
     * clean state and prevent mixing logs from different test scenarios
     * 
     * @return void
     * @see initializeXHRMonitoring() For the setup of the logging system
     */
    public function clearXHRLog(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            window.exfXHRLog = {
                requests: [],
                lastRequest: null,
                errors: []
            };
            JS
        );
    }



    /**
     * Initializes XHR and AJAX Request Monitoring System
     * 
     * This function sets up a comprehensive monitoring system for all network requests by:
     * - Creating a wrapper around XMLHttpRequest without modifying its core functionality (Uses wrapper pattern instead of modifying original XHR)
     * - Monitoring jQuery AJAX calls through $.ajaxSetup
     * - Tracking all fetch API requests , Catches HTTP errors (400, 500 etc.)
     * 
     * Features:
     * - Captures all network activity including status codes and responses
     * - Detects HTTP errors (400, 500 etc.) and UI5 specific errors
     * - Logs detailed request information (timestamps, duration, responses)
     * - Stores logs separately in window.exfXHRLog without affecting application
     * 
     * Use Cases:
     * - Test automation error detection
     * - Network request debugging
     * - Error state capturing
     * - Automatic error logging
     * 
     * @method initializeXHRMonitoring
     * @return void
     * @throws \RuntimeException if XHR monitoring initialization fails
     */
    public function initializeXHRMonitoring(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            (function() {
                // Initialize global XHR logging object with tracking arrays
                window.exfXHRLog = {
                    requests: [],    // Array to store all network requests
                    errors: [],      // Array to store any error states
                    addRequest: function(request) {
                        // Add timestamp to each request for tracking
                        request.timestamp = new Date().toISOString();
                        
                        // Store request in history array
                        this.requests.push(request);
                        
                        // Check for error status codes (400+)
                        if (request.status >= 400) {
                            this.errors.push({
                                type: 'HTTPError',
                                status: request.status,
                                url: request.url,
                                message: request.statusText,
                                response: request.response,
                                timestamp: request.timestamp
                            });
                            console.error('XHR Error:', request);
                        }
                    }
                };
    
                // Set up jQuery AJAX request monitoring
                if (typeof jQuery !== 'undefined') {
                    const originalAjax = jQuery.ajax;
                    jQuery.ajax = function(options) {
                        const startTime = Date.now();
                        
                        // Store original callback for later execution
                        const originalComplete = options.complete;
                        
                        // Wrap the complete callback to add monitoring
                        options.complete = function(jqXHR, textStatus) {
                            try {
                                // Collect comprehensive request details
                                const request = {
                                    url: options.url,
                                    method: options.type || 'GET',
                                    status: jqXHR.status,
                                    statusText: jqXHR.statusText,
                                    response: jqXHR.responseText,
                                    duration: Date.now() - startTime
                                };

                                // Add request to monitoring log
                                window.exfXHRLog.addRequest(request);
                               
                                // Execute original callback if it exists
                                if (originalComplete) {
                                    originalComplete.apply(this, arguments);
                                }
                            } catch (e) {
                                console.error('Error in XHR logging:', e);
                            }
                        };
    
                        return originalAjax.apply(this, arguments);
                    };
                }
    
                // Set up native XMLHttpRequest monitoring
                const originalXHR = window.XMLHttpRequest;
                window.XMLHttpRequest = function() {
                    const xhr = new originalXHR();
                    const startTime = Date.now();
                    let requestUrl = '';
                    let requestMethod = '';

                    // Intercept the open method to capture request details
                    const originalOpen = xhr.open;
                    xhr.open = function(method, url) {
                        requestUrl = url;
                        requestMethod = method;
                        return originalOpen.apply(this, arguments);
                    };
                        // Add listener for request completion

                    xhr.addEventListener('loadend', function() {
                        try {
                            // Compile request information

                            const request = {
                                url: requestUrl,
                                method: requestMethod,
                                status: xhr.status,
                                statusText: xhr.statusText,
                                response: xhr.responseText,
                                duration: Date.now() - startTime
                            };
                            
                            window.exfXHRLog.addRequest(request);
                        } catch (e) {
                            console.error('Error in XHR logging:', e);
                        }
                    });
    
                    return xhr;
                };
    
                // Set up Fetch API request monitoring
                if (typeof window.fetch === 'function') {
                    const originalFetch = window.fetch;
                    window.fetch = async function(input, init) {
                        const startTime = Date.now();
                        const url = typeof input === 'string' ? input : input.url;
                        const method = init?.method || 'GET';
    
                        try {
                             // Execute original fetch request
                            const response = await originalFetch.apply(this, arguments);
                            const clone = response.clone();
                            const responseText = await clone.text();
                            
                            // Log successful request details
                            window.exfXHRLog.addRequest({
                                url: url,
                                method: method,
                                status: response.status,
                                statusText: response.statusText,
                                response: responseText,
                                duration: Date.now() - startTime
                            });
    
                            return response;
                        } catch (error) {
                            // Log failed request details
                            window.exfXHRLog.addRequest({
                                url: url,
                                method: method,
                                status: 0,
                                statusText: error.message,
                                error: error.toString(),
                                duration: Date.now() - startTime
                            });
                            throw error;
                        }
                    };
                }
    
                console.log('XHR monitoring initialized successfully');
            })();
    JS
        );

        // Verify that monitoring system was initialized correctly
        $isInitialized = $this->getSession()->evaluateScript('return typeof window.exfXHRLog !== "undefined" && typeof window.exfXHRLog.addRequest === "function"');
        if (!$isInitialized) {
            throw new \RuntimeException('XHR monitoring initialization failed');
        }
    }

 







    

     

    /**
     * Finds an input element by its associated label caption in a UI5 application
     * 
     * This function performs a hierarchical search to find input elements:
     * 1. First finds the label element with matching caption
     * 2. Then locates the corresponding input through the label's 'for' attribute
     * 3. Handles different UI5 input structures and nested elements
     * 
     * @param string $caption
     * @param \Behat\Mink\Element\NodeElement|null $parent
     * @return NodeElement|null
     */
    public function findInputByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        // Get the page or use provided parent element as search context
        $page = $this->getPage();
        $input = null;

        // Find all label BDI elements (UI5 uses BDI for bidirectional text support)
        $labelBdis = ($parent ?? $page)->findAll('css', 'label.sapMLabel > span > bdi');

        // Iterate through found labels to locate matching one
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                try {
                    // Navigate from BDI to actual label element
                    $sapMLabel = $labelBdi->getParent()->getParent();
                    $labelFor = $sapMLabel->getAttribute('for');

                    // First attempt: Try to find input directly by ID
                    $input = ($parent ?? $page)->findById($labelFor);

                    // Second attempt: Look for inner input element
                    // UI5 often wraps inputs in containers with -inner suffix
                    if (!$input) {
                        $input = ($parent ?? $page)->find('css', '#' . $labelFor . '-inner');
                    }

                    // Third attempt: Check for nested input within container
                    // Some UI5 controls have complex DOM structures
                    if (!$input) {
                        $inputContainer = ($parent ?? $page)->find('css', '#' . $labelFor);
                        if ($inputContainer) {
                            $input = $inputContainer->find('css', 'input.sapMInputBaseInner');
                        }
                    }
                    // If input found, break the loop
                    if ($input) {
                        break;
                    }
                } catch (\Exception $e) {
                    continue;
                }
            }
        }

        return $input;
    }

    public function findTabByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        // Find all label BDI elements (UI5 uses BDI for bidirectional text support)
        $tabHeadings = ($parent ?? $this->getPage())->findAll('css', '.sapMITBItem .sapMITHTextContent ');

        // Iterate through found labels to locate matching one
        foreach ($tabHeadings as $tabHeading) {
            if ($tabHeading->getText() === $caption && $tabHeading->isVisible()) {
                return $tabHeading->getParent()->getParent()->getParent();
            }
        }
        return null;
    }

    /**
     * 
     * @param string $caption
     * @param \Behat\Mink\Element\NodeElement|null $parent
     * @param int $attempts
     * @return NodeElement|null
     */
    public function goToTab(string $caption, NodeElement $parent = null, int $attempts = 1): ?NodeElement
    {
        $tab = $this->findTabByCaption($caption, $parent);
        if ($tab === null && $attempts > 1) {
            // $this->waitManager->waitForPendingOperations(false, true, true);  // Replace sleep(1)
            $attempts--;
            return $this->goToTab($caption, $parent, $attempts);
        }
        Assert::assertNotNull($tab, 'Cannot find tab "' . $caption . '"');
        // If the tab is not active, click on it to switch to the right authenticator
        if (!$tab->hasClass('sapMITBSelected')) {
            $tab->click();
        }
        return $tab;
    }

    /**
     * 
     * @param string $caption
     * @param \Behat\Mink\Element\NodeElement|null $parent
     * @return NodeElement
     */
    public function findButtonByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $page = $this->getPage();
        // $input = $page->find('xpath', '//*/label/span/bdi[contains(text(), "' . $caption . '")]');
        // $labelBdi = $page->find('named', ['content', $caption]);
        $button = null;
        $labelBdis = ($parent ?? $page)->findAll('css', 'button.sapMBtn > span > span > bdi');
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                $button = $labelBdi->getParent()->getParent()->getParent();
                break;
            }
        }
        return $button;
    }

  
 
   

     
    /**
     * Enhanced findWidgets method with better widget detection
     * 
     * @param string $widgetType
     * @param NodeElement|null $parent
     * @param int $timeoutInSeconds
     * @return NodeElement[]
     */
    public function findWidgets(string $widgetType, NodeElement $parent = null, int $timeoutInSeconds = 2): array
    {
        // Initialize search context - either parent element or full page
        $searchContext = $parent ?? $this->getPage();
        $widgets = [];
        $foundIds = [];


        switch ($widgetType) {
            case 'Dialog':
                // Define selectors for different types of UI5 dialogs
                $selectors = [
                    // Core dialog selectors
                    '.sapMDialog',
                    '[role="dialog"]',
                    // Message and popup dialogs
                    '.sapMMessageDialog',
                    '.sapMPopover[role="dialog"]',
                    // Dialog content containers
                    '.sapMDialogSection',
                    '.sapMDialogScroll',
                    // Custom dialog classes
                    '.exf-dialog-page',
                    //
                    '.sapMDialog-CTX',
                    '.sapMDialogBlock',
                    '.sapMPopover',
                    '.sapUiRespDialog',
                ];
                // Search for each dialog type

                foreach ($selectors as $selector) {
                    $elements = $searchContext->findAll('css', $selector);
                    foreach ($elements as $element) {
                        try {
                            $elementId = $element->getAttribute('id');

                            // Skip already processed elements to avoid duplicates
                            if (in_array($elementId, $foundIds)) {
                                continue;
                            }

                            // Validate that element is a proper dialog
                            if (!$this->isValidDialog($element)) {
                                continue;
                            }

                            // Get dialog text content for filtering
                            $dialogText = $this->extractDialogText($element);

                            // Filter by objectAlias if specified
                            if (!empty($this->objectAlias)) {
                                if (stripos($dialogText, $this->objectAlias) !== false) {
                                    $widgets[] = $element;
                                    $foundIds[] = $elementId;
                                }
                            } else {
                                $widgets[] = $element;
                                $foundIds[] = $elementId;
                            }
                        } catch (\Exception $e) {
                            continue;
                        }
                    }
                }
                break;

            case 'Input':
                // Search for UI5 input elements
                $widgets = [];
                $foundIds = [];

                $mainInputs = $searchContext->findAll('css', '.sapMInputBase');
                foreach ($mainInputs as $input) {
                    try {
                        $elementId = $input->getAttribute('id');
                        // Check for duplicate IDs
                        if (!in_array($elementId, $foundIds)) {
                            // Verify element has actual input field
                            $inner = $input->find('css', '.sapMInputBaseInner');
                            if ($inner && $inner->isVisible()) {
                                $widgets[] = $input;
                                $foundIds[] = $elementId;
                            }
                        }
                    } catch (\Exception $e) {
                        continue;
                    }
                }

                // Debug  
                echo "\nFound input elements:" . count($mainInputs) . "\n";
                foreach ($widgets as $index => $widget) {
                    echo "Input #" . ($index + 1) . ":\n";
                    echo "ID: " . $widget->getAttribute('id') . "\n";
                    echo "Classes: " . $widget->getAttribute('class') . "\n";
                    echo "Inner input exists: " . ($widget->find('css', '.sapMInputBaseInner') ? 'yes' : 'no') . "\n";
                    echo "---\n";
                }

                // Return only main input containers
                return array_values(array_filter($widgets, function ($widget) {
                    return strpos($widget->getAttribute('class'), 'sapMInputBase') !== false;
                }));
                break;


            case 'DataTable':
                // Define selectors for different UI5 table types
                $tableSelectors = [
                    '.sapUiTable',                  // Grid Table
                    '.sapMTable',                   // Responsive Table
                    '.sapMList[role="grid"]',       // List as Table
                    '[role="grid"]',                // Generic Grid Role
                    '.exfw-DataTable'               // Custom DataTable Class
                ];
                // Search through each table type

                foreach ($tableSelectors as $selector) {
                    $tables = $searchContext->findAll('css', $selector);

                    foreach ($tables as $table) {
                        try {
                            // Validate table structure
                            if (!$this->isValidTable($table)) {
                                continue;
                            }

                            // Build complete table content for filtering
                            $allContent = '';

                            // Check table title
                            $title = $table->find('css', '.sapMTitle, .sapUiTableTitle');
                            if ($title) {
                                $allContent .= ' ' . $title->getText();
                            }

                            // Get column headers
                            $headers = $table->findAll('css', 'th, [role="columnheader"]');
                            foreach ($headers as $header) {
                                $headerText = $header->find('css', '.sapMLabel, .sapUiTableColText');
                                if ($headerText) {
                                    $allContent .= ' ' . $headerText->getText();
                                }
                            }

                            // Tablo hücreleri
                            $cells = $table->findAll('css', 'td, [role="gridcell"]');
                            foreach ($cells as $cell) {
                                $cellText = $cell->find('css', '.sapMText, .sapUiTableCell');
                                if ($cellText) {
                                    $allContent .= ' ' . $cellText->getText();
                                }
                            }

                            // Filter by objectAlias if specified
                            if (!empty($this->objectAlias)) {
                                if (stripos($allContent, $this->objectAlias) !== false) {
                                    $widgets[] = $table;
                                }
                            } else {
                                $widgets[] = $table;
                            }
                        } catch (\Exception $e) {
                            continue;
                        }
                    }
                }
                break;


            default:
                $widgets = $searchContext->findAll('css', ".exfw-{$widgetType}");
        }

        // Filter visible widgets and deduplicate by content
        $visibleWidgets = array_filter($widgets, function ($widget) {
            try {
                return $widget->isVisible();
            } catch (\Exception $e) {
                return false;
            }
        });

        // // Debug logging
        // //echo "\n-------- DEBUG: Found Widgets --------\n";
        // foreach ($visibleWidgets as $index => $widget) {
        //     try {
        //         echo "Widget #" . ($index + 1) . ":\n";
        //         echo "ID: " . ($widget->getAttribute('id') ?? 'no id') . "\n";
        //         echo "Classes: " . ($widget->getAttribute('class') ?? 'no class') . "\n";
        //         echo "Role: " . ($widget->getAttribute('role') ?? 'no role') . "\n";
        //         echo "Content Hash: " . md5($widget->getText()) . "\n";
        //         echo "-----------------\n";
        //     } catch (\Exception $e) {
        //         continue;
        //     }
        // }

        // // objectAlias ile filtrele
        // if (!empty($visibleWidgets) && !empty($this->objectAlias)) {
        //     $filteredWidgets = array_filter($visibleWidgets, function ($widget) {
        //         try {
        //             return strpos($widget->getText(), $this->objectAlias) !== false;
        //         } catch (\Exception $e) {
        //             return false;
        //         }
        //     });
        //     return array_values($filteredWidgets);
        // }

        return array_values(array_filter($widgets, function ($widget) {
            try {
                return $widget->isVisible();
            } catch (\Exception $e) {
                return false;
            }
        }));
    }

    /**
     * Validates if a DOM element represents a proper UI5 table structure
     * @param NodeElement $element Element to check
     * @return bool True if element is a valid dialog
     */
    protected function isValidDialog(NodeElement $element): bool
    {
        try {
            // Must be visible
            // First check: Element must be visible in the DOM
            // This ensures we're not processing hidden template elements
            if (!$element->isVisible()) {
                return false;
            }

            // Check for essential dialog attributes
            $role = $element->getAttribute('role');
            $classes = $element->getAttribute('class');

            // Must have dialog role or specific dialog classes
            if (
                $role !== 'dialog' &&
                !preg_match('/(sapMDialog|sapMMessageDialog|sapMPopover)/', $classes)
            ) {
                return false;
            }

            // Should have either a header or content section
            $hasHeader = $element->find('css', '.sapMDialogTitle, .sapMIBar-CTX') !== null;
            $hasContent = $element->find('css', '.sapMDialogSection, .sapMDialogContent') !== null;

            return $hasHeader || $hasContent;

        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Extracts text content from a dialog element
     * 
     * @param NodeElement $element Dialog element
     * @return string Concatenated text content
     */
    protected function extractDialogText(NodeElement $element): string
    {
        $textParts = [];

        try {
            // Get header title 
            $headerTitle = $element->find('css', '.sapMDialogTitle, .sapMIBar-CTX .sapMTitle');
            if ($headerTitle) {
                $textParts[] = trim($headerTitle->getText());
            }

            // Get content text
            $textElements = $element->findAll('css', '.sapMDialogContent .sapMText, .sapMDialogContent .sapMLabel');
            foreach ($textElements as $textElement) {
                $text = trim($textElement->getText());
                if (!empty($text)) {
                    $textParts[] = $text;
                }
            }

            // Get button texts
            $buttons = $element->findAll('css', '.sapMDialogFooter .sapMBtn, .sapMBar-CTX .sapMBtn');
            foreach ($buttons as $button) {
                $buttonText = $button->find('css', '.sapMBtnContent');
                if ($buttonText) {
                    $textParts[] = trim($buttonText->getText());
                }
            }

        } catch (\Exception $e) {
            // If any error occurs, return empty string
            return '';
        }

        return implode(' ', array_filter($textParts));
    }

    /**
     * Validates if a DOM element represents a proper UI5 table structure
     *  
     * 
     * @param NodeElement $table The element to validate as a table
     * @return bool True if element is a valid UI5 table, false otherwise
     */
    protected function isValidTable(NodeElement $table): bool
    {
        try {
            // First check: Element must be visible in the DOM
            // This ensures we're not processing hidden template elements
            if (!$table->isVisible()) {
                return false;
            }

            // Second check: Look for table structural elements
            // Search for both standard table headers (th) and UI5 grid headers (role="columnheader")
            $hasHeaders = count($table->findAll('css', 'th, [role="columnheader"]')) > 0;
            // Third check: Look for table cells
            // Search for both standard cells (td) and UI5 grid cells (role="gridcell")
            $hasCells = count($table->findAll('css', 'td, [role="gridcell"]')) > 0;

            // A valid table must have either headers or cells
            // - Headers without cells: Empty table with column definitions
            // - Cells without headers: Data grid without column labels
            // - Both headers and cells: Standard populated table
            return $hasHeaders || $hasCells;

        } catch (\Exception $e) {
            // If any error occurs during validation (e.g., stale element reference)
            // consider the table invalid
            return false;
        }
    }

    /**
     * Returns the type of the widget, that the given node belongs to
     * 
     * @param \Behat\Mink\Element\NodeElement $node
     * @return bool|string|null
     */
    public function getNodeWidgetType(NodeElement $node): ?string
    {
        $classes = $node->getAttribute('class');
        $type = null;
        foreach (explode(' ', $classes ?? '') as $class) {
            if (mb_stripos($class, 'exfw-') === 0) {
                $type = StringDataType::substringAfter($class, 'exfw-');
            }
        }
        if ($type === null) {
            // TODO search the parents of the node for the first one with `exfw` CSS class
            // and take the widget type from that node
        }
        return $type;
    }



    /**
     * 
     * @param string $pageUrl
     * @param string $widgetId
     * @param string $assertWidgetType
     * @return \exface\Core\Interfaces\WidgetInterface
     */
    protected function getWidget(string $pageUrl, string $widgetId = null, string $assertWidgetType = null)
    {
        $page = UiPageFactory::createFromModel($this->getWorkbench(), $pageUrl);
        $widget = $widgetId !== null ? $page->getWidget($widgetId) : $page->getWidgetRoot();
        if ($assertWidgetType !== null) {
            Assert::assertEquals($assertWidgetType, $widget->getType(), 'Widget ' . $widgetId . ' is not of expected type "' . $assertWidgetType . '"!');
        }
        return $widget;
    }

 
    public static function setupUser(WorkbenchInterface $workbench, array $roles, string $locale = null): array
    {
        $config = $workbench->getApp('axenox.BDT')->getConfig();
        $userSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER');
        $userSheet->getFilters()->addConditionFromString('USERNAME', $config->getOption('TEST_USER.USERNAME'), ComparatorDataType::EQUALS);
        $userSheet->getColumns()->addFromSystemAttributes();
        $userSheet->getColumns()->addMultiple([
            'USERNAME'
        ]);
        $userSheet->dataRead();
        if ($userSheet->isEmpty()) {
            $userSheet->addRow([
                'USERNAME' => $config->getOption('TEST_USER.USERNAME'),
                'PASSWORD' => $config->getOption('TEST_USER.PASSWORD'),
                'FIRST_NAME' => $config->getOption('TEST_USER.FIRST_NAME'),
                'LAST_NAME' => $config->getOption('TEST_USER.LAST_NAME'),
                'LOCALE' => $workbench->getConfig()->getOption('SERVER.DEFAULT_LOCALE')
            ]);
            $userSheet->dataCreate();
        }
        $userId = $userSheet->getUidColumn()->getValue(0);

        if ($locale) {
            $userSheet->setCellValue('LOCALE', 0, $locale);
        }

        if (!empty($roles)) {
            $roleSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE');
            $roleSheet->getColumns()->addFromSystemAttributes();
            $roleSheet->getFilters()
                ->addNestedOR()
                ->addConditionFromValueArray('ALIAS_WITH_NS', $roles)
                ->addConditionFromValueArray('NAME', $roles);
            $roleSheet->dataRead();

            $userRoleSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE_USERS');
            $userRoleSheet->getFilters()->addConditionFromString('USER', $userId);
            foreach ($roleSheet->getUidColumn()->getValues() as $roleUid) {
                $userRoleSheet->addRow([
                    'USER_ROLE' => $roleUid
                ]);
            }
            $userSheet->setCellValue('USER_ROLE_USERS', 0, $userRoleSheet->exportUxonObject()->toArray());
        }
        $userSheet->dataUpdate();

        $loginFields = [];
        foreach ($workbench->getConfig()->getOption('SECURITY.AUTHENTICATORS') as $authUxon) {
            if ($authUxon->getProperty('class') === '\\' . MetamodelAuthenticator::class) {
                $loginDataObj = MetaObjectFactory::createFromString($workbench, 'exface.Core.LOGIN_DATA');
                $loginFields['_tab'] = $authUxon->getProperty('name') ?? $workbench->getCoreApp()->getTranslator()->translate('SECURITY.SIGN_IN');
                $loginFields[$loginDataObj->getAttribute('USERNAME')->getName()] = $config->getOption('TEST_USER.USERNAME');
                $loginFields[$loginDataObj->getAttribute('PASSWORD')->getName()] = $config->getOption('TEST_USER.PASSWORD');
                $loginAction = ActionFactory::createFromString($workbench, Login::class);
                $loginFields['_button'] = $loginAction->getName();
            }
        }
        return $loginFields;
    }

    public static function resetUser(WorkbenchInterface $workbench): void
    {
        $config = $workbench->getApp('axenox.BDT')->getConfig();
        $dataSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE_USERS');
        $dataSheet->getFilters()->addConditionFromString('USER__USERNAME', $config->getOption('TEST_USER.USERNAME'), ComparatorDataType::EQUALS);
        $dataSheet->dataDelete();
        return;
    }

    private function getCurrentUrlInfo(): array
    {
      
        return $this->getSession()->evaluateScript('
        (function() {
            var baseUrl = window.location.href.split("#")[0];
            var fullUrl = window.location.href;
            
            // UI5 specific routing information
            var ui5Hash = "";
            if (typeof sap !== "undefined" && 
                sap.ui && 
                sap.ui.core && 
                sap.ui.core.routing && 
                sap.ui.core.routing.HashChanger) {
                
                try {
                    // Get the current hash from UI5 router
                    ui5Hash = sap.ui.core.routing.HashChanger.getInstance().getHash();
                } catch(e) {
                    ui5Hash = window.location.hash.replace("#", "");
                }
            } else {
                ui5Hash = window.location.hash.replace("#", "");
            }
            
            return {
                baseUrl: baseUrl,
                fullUrl: fullUrl,
                hash: ui5Hash
            };
        })()
    ');
    }
} 